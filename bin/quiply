#!/usr/bin/env ruby

#              _       _
#   __ _ _   _(_)_ __ | |_   _
#  / _` | | | | | '_ \| | | | |
# | (_| | |_| | | |_) | | |_| |
#  \__, |\__,_|_| .__/|_|\__, |
#   by|_|stephan|_|dotcom|___/

# quiply - cohorts challenge

require 'methadone'
require 'pry'
require 'groupdate'
require 'quiply'

include Methadone::Main
include Methadone::CLILogging
include Quiply

def to_percent(count, total, digits = 0)
  "#{((count * 100) / total).round(digits)}%"
end

SPAN_FORMAT = '%-m/%-d'.freeze
def timespan_format(span)
  [span.first, span.last].map { |t| t.strftime(SPAN_FORMAT) }.join('-')
end

main do |users_csv, orders_csv|
  Groupdate.week_start = options[:start_day].to_sym
  maxweeks = options[:weeks].to_i
  Import.new(User).import(users_csv)
  Import.new(Order).import(orders_csv)
  puts "there are now #{User.count} users with #{Order.count} orders"

  rows = []
  by_week = User.group_by_week(:created_at).count
  by_week.each do |week, count|
    new_row = []
    timespan = week..(week + 1.week)
    new_row << timespan_format(timespan)
    users = User.where(created_at: timespan)
    new_row << "#{count} users" # pluralize?
    # find all orders made by these users, ever
    user_orders = Order.where(user_id: users.pluck(:old_id))

    previously_ordered_ids = []
    user_orders.group_by_week(:created_at).count.each_with_index do |(week, count), weeknum|
      next if weeknum >= maxweeks
      order_timespan = week..(week + 1.week)
      sub_orders = user_orders.where(created_at: order_timespan)
      orderer_ids = sub_orders.pluck(:user_id).uniq
      new_orderer_ids = orderer_ids - previously_ordered_ids
      # puts weeknum.to_s * 40
      # puts "count should be #{count} is #{sub_orders.count}"
      # puts timespan_format(order_timespan)
      # puts orderer_ids.sort.inspect
      # puts previously_ordered_ids.sort.inspect
      # puts new_orderer_ids.sort.inspect
      # puts weeknum.to_s * 40
      col_data = "#{to_percent(orderer_ids.count, users.count)} orderers (#{orderer_ids.count})\n#{to_percent(new_orderer_ids.count, users.count)} 1st Time (#{new_orderer_ids.count})"
      previously_ordered_ids = (previously_ordered_ids + orderer_ids).uniq
      new_row << col_data
    end

    rows << new_row
  end

  headings = %w[Cohort Users]
  max_cols = [rows.map(&:length).max, maxweeks + 2].min
  headings += (0...(max_cols-2)).map { |w| "#{w*7}-#{(w+1)*7} days" }

  # pad out rows
  rows = rows.map { |r| (r + [nil]*max_cols).first(max_cols) }

  table = Terminal::Table.new rows: rows.reverse,
                              headings: headings, #%w[Cohort Users 0-7 7-14 14-21 ...],
                              title: 'Cohort Challenge',
                              style: {all_separators: true}
  table.align_column(1, :right)
  puts table
  pry
end

options[:weeks] = '8'
options[:format] = 'txt'
options[:start_day] = 'sun'

description <<~EODESC
  given input CSV files of orders and users, group users into cohorts joined by week,
  further subdivided into groups who placed a order in a given week after joining
EODESC

on('-w VALUE', '--weeks', 'override total weeks back of cohorts, default: 8')
formats = %w[txt html csv]
on('-f VALUE', '--format', formats, 'output format, default: txt', "(#{formats.join('|')})")
days = %w[sun mon tue wed thu fri sat]
on('-s VALUE', '--start_day', days, 'day to start week, default: sun', "(#{days.join('|')})")

arg :users_csv, :required, 'input filename for users csv.'
arg :orders_csv, :required, 'input filename for orders csv.'

version Quiply::VERSION, compact: true

go!
